# Setup API OpenAI + Agentes Especializados
## Caso de Uso: Marketing Multiidioma para Hotel + Relojer√≠a

### üéØ Objetivo del Ejercicio
Crear **2 APIs especializadas** que trabajen en conjunto para generar contenido de marketing multiidioma desde sistemas legacy (SAP) sin IA.

**Flujo completo**:
```
SAP/Sistema Legacy ‚Üí API 1 (Marketing) ‚Üí API 2 (Traducci√≥n) ‚Üí Contenido Final
```

---

## 1. Setup Inicial de OpenAI API

### üìã Prerrequisitos
```bash
# Instalar dependencias
pip install openai fastapi uvicorn python-dotenv pydantic
```

### üîë Configuraci√≥n de API Key
```python
# .env
OPENAI_API_KEY=sk-your-api-key-here
OPENAI_MODEL=gpt-4o-mini  # M√°s econ√≥mico para desarrollo
```

### ‚öôÔ∏è Configuraci√≥n Base
```python
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
    API_HOST = "0.0.0.0"
    API_PORT = 8000
    
    # Configuraci√≥n de prompts
    MAX_TOKENS = 1500
    TEMPERATURE = 0.7
    
settings = Settings()
```

---

## 2. Cliente OpenAI Base

### üîß Cliente Configurado
```python
# openai_client.py
from openai import OpenAI
from config import settings
import logging

logger = logging.getLogger(__name__)

class OpenAIClient:
    def __init__(self):
        self.client = OpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL
    
    async def generate_completion(
        self, 
        system_prompt: str, 
        user_prompt: str,
        temperature: float = 0.7,
        max_tokens: int = 1500
    ) -> str:
        """Genera una completaci√≥n usando GPT"""
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=temperature,
                max_tokens=max_tokens
            )
            
            result = response.choices[0].message.content
            logger.info(f"OpenAI completion generated: {len(result)} characters")
            return result
            
        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}")
            raise Exception(f"Error generando contenido: {str(e)}")
    
    def estimate_cost(self, input_tokens: int, output_tokens: int) -> float:
        """Estima el costo de la llamada (GPT-4o-mini pricing)"""
        input_cost = (input_tokens / 1000) * 0.00015  # $0.15 per 1K tokens
        output_cost = (output_tokens / 1000) * 0.0006  # $0.60 per 1K tokens
        return input_cost + output_cost

# Instancia global
openai_client = OpenAIClient()
```

---

## 3. API 1: Generador de Descripciones de Marketing

### üìù Modelos de Datos
```python
# models.py
from pydantic import BaseModel, Field
from typing import List, Optional
from enum import Enum

class ProductType(str, Enum):
    HOTEL_SERVICE = "hotel_service"
    HOTEL_AMENITY = "hotel_amenity" 
    LUXURY_WATCH = "luxury_watch"
    JEWELRY = "jewelry"
    SPA_SERVICE = "spa_service"

class ProductSpecs(BaseModel):
    name: str = Field(..., description="Nombre del producto/servicio")
    type: ProductType = Field(..., description="Tipo de producto")
    category: str = Field(..., description="Categor√≠a espec√≠fica")
    features: List[str] = Field(..., description="Caracter√≠sticas principales")
    materials: Optional[List[str]] = Field(None, description="Materiales (relojes/joyas)")
    price_range: Optional[str] = Field(None, description="Rango de precio")
    target_audience: str = Field(..., description="P√∫blico objetivo")
    unique_selling_points: List[str] = Field(..., description="Puntos de venta √∫nicos")
    
class MarketingRequest(BaseModel):
    product: ProductSpecs
    style: str = Field(default="luxury", description="Estilo de marketing")
    tone: str = Field(default="elegant", description="Tono de comunicaci√≥n")
    max_words: int = Field(default=150, description="M√°ximo de palabras")

class MarketingResponse(BaseModel):
    title: str
    description: str
    key_benefits: List[str]
    call_to_action: str
    seo_keywords: List[str]
    word_count: int
```

### üé® Agente de Marketing
```python
# marketing_agent.py
from models import MarketingRequest, MarketingResponse, ProductType
from openai_client import openai_client
import json
import re

class MarketingAgent:
    def __init__(self):
        self.system_prompts = {
            ProductType.HOTEL_SERVICE: self._get_hotel_service_prompt(),
            ProductType.HOTEL_AMENITY: self._get_hotel_amenity_prompt(),
            ProductType.LUXURY_WATCH: self._get_luxury_watch_prompt(),
            ProductType.JEWELRY: self._get_jewelry_prompt(),
            ProductType.SPA_SERVICE: self._get_spa_service_prompt()
        }
    
    def _get_hotel_service_prompt(self) -> str:
        return """
        Eres un experto en marketing hotelero de lujo. Tu tarea es crear descripciones de marketing elegantes y persuasivas para servicios de hotel de 5 estrellas.

        ESTILO:
        - Lenguaje sofisticado pero accesible
        - Enfoque en la experiencia y emociones
        - Vocabulario de lujo sin sonar pretencioso
        - Beneficios emocionales y racionales

        ESTRUCTURA DE RESPUESTA (JSON):
        {
            "title": "T√≠tulo atractivo del servicio",
            "description": "Descripci√≥n principal de marketing",
            "key_benefits": ["Beneficio 1", "Beneficio 2", "Beneficio 3"],
            "call_to_action": "Llamada a la acci√≥n espec√≠fica",
            "seo_keywords": ["keyword1", "keyword2", "keyword3", "keyword4", "keyword5"]
        }

        DIRECTRICES:
        - Usa palabras como: exclusivo, personalizado, excepcional, refinado
        - Enf√≥cate en la experiencia √∫nica del hu√©sped
        - Incluye beneficios tangibles e intangibles
        - SEO keywords relevantes para hoteles de lujo
        """
    
    def _get_luxury_watch_prompt(self) -> str:
        return """
        Eres un copywriter especializado en relojer√≠a de alta gama y lujo. Creas descripciones que conectan la artesan√≠a con el estilo de vida aspiracional.

        ESTILO:
        - Vocabulario t√©cnico de relojer√≠a cuando apropiado
        - Enfoque en herencia, tradici√≥n y innovaci√≥n
        - Lenguaje que evoca precisi√≥n y exclusividad
        - Conexi√≥n emocional con momentos importantes

        ESTRUCTURA DE RESPUESTA (JSON):
        {
            "title": "T√≠tulo que capture la esencia del reloj",
            "description": "Descripci√≥n de marketing premium",
            "key_benefits": ["Caracter√≠stica t√©cnica 1", "Beneficio aspiracional 2", "Valor √∫nico 3"],
            "call_to_action": "CTA dirigido a coleccionistas/compradores de lujo",
            "seo_keywords": ["reloj", "lujo", "precisi√≥n", "exclusivo", "craftsmanship"]
        }

        DIRECTRICES:
        - Menciona materiales premium (oro, platino, zafiro, etc.)
        - Destaca la artesan√≠a y atenci√≥n al detalle
        - Incluye aspectos t√©cnicos importantes (movimiento, resistencia, etc.)
        - Conecta con ocasiones especiales y logros personales
        """
    
    def _get_jewelry_prompt(self) -> str:
        return """
        Eres un experto en marketing de joyer√≠a de lujo. Creas textos que transforman piezas en s√≠mbolos de amor, √©xito y belleza.

        ESTILO:
        - Lenguaje emotivo y evocativo
        - Enfoque en significado y simbolismo
        - Vocabulario de lujo y exclusividad
        - Conexi√≥n con momentos especiales de la vida

        ESTRUCTURA DE RESPUESTA (JSON):
        {
            "title": "T√≠tulo que evoque belleza y exclusividad",
            "description": "Descripci√≥n que conecte emoci√≥n y calidad",
            "key_benefits": ["Valor emocional", "Calidad t√©cnica", "Exclusividad"],
            "call_to_action": "CTA que motive la compra por significado",
            "seo_keywords": ["joyer√≠a", "lujo", "exclusivo", "diamante", "regalo"]
        }

        DIRECTRICES:
        - Destaca gemas, metales preciosos y dise√±o √∫nico
        - Conecta con ocasiones especiales (bodas, aniversarios, logros)
        - Enfatiza la durabilidad y valor a largo plazo
        - Usa lenguaje que evoque emociones positivas
        """
    
    def _get_hotel_amenity_prompt(self) -> str:
        return """
        Especialista en marketing de amenities hoteleros de lujo. Transformas servicios adicionales en experiencias memorables.

        ESTILO: Enfoque en confort, conveniencia y experiencia premium del hu√©sped.
        RESPONDE EN FORMATO JSON con la estructura especificada.
        """
    
    def _get_spa_service_prompt(self) -> str:
        return """
        Experto en marketing de servicios de spa y wellness. Creas descripciones que evocan relajaci√≥n, bienestar y transformaci√≥n personal.

        ESTILO: Lenguaje que conecte bienestar f√≠sico y mental con lujo y exclusividad.
        RESPONDE EN FORMATO JSON con la estructura especificada.
        """
    
    async def generate_marketing_content(self, request: MarketingRequest) -> MarketingResponse:
        """Genera contenido de marketing basado en especificaciones del producto"""
        
        # Seleccionar prompt seg√∫n tipo de producto
        system_prompt = self.system_prompts.get(
            request.product.type, 
            self.system_prompts[ProductType.HOTEL_SERVICE]
        )
        
        # Construir prompt de usuario
        user_prompt = self._build_user_prompt(request)
        
        # Generar contenido
        raw_response = await openai_client.generate_completion(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.7,
            max_tokens=1500
        )
        
        # Parsear respuesta JSON
        try:
            content_data = self._parse_json_response(raw_response)
            
            # Crear respuesta estructurada
            response = MarketingResponse(
                title=content_data["title"],
                description=content_data["description"],
                key_benefits=content_data["key_benefits"],
                call_to_action=content_data["call_to_action"],
                seo_keywords=content_data["seo_keywords"],
                word_count=len(content_data["description"].split())
            )
            
            return response
            
        except Exception as e:
            raise Exception(f"Error procesando respuesta de marketing: {str(e)}")
    
    def _build_user_prompt(self, request: MarketingRequest) -> str:
        """Construye el prompt espec√≠fico para el producto"""
        
        features_text = ", ".join(request.product.features)
        usp_text = ", ".join(request.product.unique_selling_points)
        materials_text = ", ".join(request.product.materials) if request.product.materials else "No especificado"
        
        prompt = f"""
        PRODUCTO A PROMOCIONAR:
        Nombre: {request.product.name}
        Tipo: {request.product.type.value}
        Categor√≠a: {request.product.category}
        Caracter√≠sticas: {features_text}
        Materiales: {materials_text}
        Rango de precio: {request.product.price_range or "Premium"}
        P√∫blico objetivo: {request.product.target_audience}
        Puntos √∫nicos de venta: {usp_text}
        
        REQUERIMIENTOS:
        - Estilo: {request.style}
        - Tono: {request.tone}
        - M√°ximo de palabras en descripci√≥n: {request.max_words}
        - Respuesta en formato JSON v√°lido
        
        Genera contenido de marketing que destaque los beneficios √∫nicos y conecte emocionalmente con el p√∫blico objetivo.
        """
        
        return prompt
    
    def _parse_json_response(self, raw_response: str) -> dict:
        """Extrae y parsea JSON de la respuesta"""
        try:
            # Buscar JSON en la respuesta
            json_match = re.search(r'\{.*\}', raw_response, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                return json.loads(json_str)
            else:
                raise ValueError("No se encontr√≥ JSON v√°lido en la respuesta")
        except json.JSONDecodeError as e:
            raise ValueError(f"Error decodificando JSON: {str(e)}")

# Instancia global
marketing_agent = MarketingAgent()
```

### üöÄ API Endpoint para Marketing
```python
# api_marketing.py
from fastapi import FastAPI, HTTPException
from models import MarketingRequest, MarketingResponse
from marketing_agent import marketing_agent
import logging

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="API Generador de Marketing",
    description="API especializada en generar contenido de marketing para productos de lujo",
    version="1.0.0"
)

@app.post("/generate-marketing", response_model=MarketingResponse)
async def generate_marketing_content(request: MarketingRequest):
    """
    Genera contenido de marketing profesional basado en especificaciones del producto.
    
    Especializado en:
    - Servicios hoteleros de lujo
    - Relojer√≠a de alta gama  
    - Joyer√≠a exclusiva
    - Servicios de spa y wellness
    """
    try:
        logger.info(f"Generando marketing para: {request.product.name}")
        
        response = await marketing_agent.generate_marketing_content(request)
        
        logger.info(f"Marketing generado exitosamente: {response.word_count} palabras")
        return response
        
    except Exception as e:
        logger.error(f"Error generando marketing: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check del servicio"""
    return {"status": "healthy", "service": "marketing-generator"}

if __name__ == "__main__":
    import uvicorn
    from config import settings
    
    uvicorn.run(
        "api_marketing:app", 
        host=settings.API_HOST, 
        port=8001,  # Puerto espec√≠fico para marketing
        reload=True
    )
```

---

## 4. API 2: Traductor Especializado

### üåç Modelos para Traducci√≥n
```python
# translation_models.py
from pydantic import BaseModel, Field
from typing import List, Dict
from enum import Enum

class TargetLanguage(str, Enum):
    ENGLISH = "en"
    FRENCH = "fr"
    ITALIAN = "it"
    GERMAN = "de"
    PORTUGUESE = "pt"
    CATALAN = "ca"

class ContentType(str, Enum):
    MARKETING = "marketing"
    TECHNICAL = "technical"
    LEGAL = "legal"
    HOSPITALITY = "hospitality"
    LUXURY_GOODS = "luxury_goods"

class TranslationRequest(BaseModel):
    source_text: str = Field(..., description="Texto a traducir")
    source_language: str = Field(default="es", description="Idioma origen")
    target_languages: List[TargetLanguage] = Field(..., description="Idiomas destino")
    content_type: ContentType = Field(..., description="Tipo de contenido")
    brand_name: str = Field(..., description="Nombre de la marca")
    preserve_brand_terms: List[str] = Field(default=[], description="T√©rminos de marca a preservar")
    cultural_adaptation: bool = Field(default=True, description="Adaptaci√≥n cultural")

class TranslationResult(BaseModel):
    language: TargetLanguage
    translated_text: str
    cultural_notes: List[str] = Field(default=[], description="Notas de adaptaci√≥n cultural")
    preserved_terms: List[str] = Field(default=[], description="T√©rminos preservados")

class TranslationResponse(BaseModel):
    source_text: str
    translations: List[TranslationResult]
    total_languages: int
    processing_time: float
```

### üîÑ Agente de Traducci√≥n
```python
# translation_agent.py
from translation_models import TranslationRequest, TranslationResponse, TranslationResult, ContentType, TargetLanguage
from openai_client import openai_client
import json
import time
from typing import List

class TranslationAgent:
    def __init__(self):
        self.language_names = {
            TargetLanguage.ENGLISH: "ingl√©s",
            TargetLanguage.FRENCH: "franc√©s", 
            TargetLanguage.ITALIAN: "italiano",
            TargetLanguage.GERMAN: "alem√°n",
            TargetLanguage.PORTUGUESE: "portugu√©s",
            TargetLanguage.CATALAN: "catal√°n"
        }
        
        self.content_type_instructions = {
            ContentType.MARKETING: "marketing de lujo y persuasivo",
            ContentType.HOSPITALITY: "hospitalidad y servicios premium",
            ContentType.LUXURY_GOODS: "bienes de lujo y exclusividad",
            ContentType.TECHNICAL: "t√©cnico y preciso",
            ContentType.LEGAL: "legal y formal"
        }
    
    async def translate_content(self, request: TranslationRequest) -> TranslationResponse:
        """Traduce contenido a m√∫ltiples idiomas con adaptaci√≥n cultural"""
        
        start_time = time.time()
        translations = []
        
        for target_lang in request.target_languages:
            try:
                translation_result = await self._translate_to_language(
                    request, target_lang
                )
                translations.append(translation_result)
                
            except Exception as e:
                # Log error pero contin√∫a con otros idiomas
                print(f"Error traduciendo a {target_lang}: {str(e)}")
                
        processing_time = time.time() - start_time
        
        return TranslationResponse(
            source_text=request.source_text,
            translations=translations,
            total_languages=len(translations),
            processing_time=round(processing_time, 2)
        )
    
    async def _translate_to_language(
        self, 
        request: TranslationRequest, 
        target_lang: TargetLanguage
    ) -> TranslationResult:
        """Traduce a un idioma espec√≠fico"""
        
        system_prompt = self._build_system_prompt(request, target_lang)
        user_prompt = self._build_user_prompt(request, target_lang)
        
        raw_response = await openai_client.generate_completion(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.3,  # M√°s conservador para traducciones
            max_tokens=2000
        )
        
        # Parsear respuesta
        result_data = self._parse_translation_response(raw_response)
        
        return TranslationResult(
            language=target_lang,
            translated_text=result_data["translated_text"],
            cultural_notes=result_data.get("cultural_notes", []),
            preserved_terms=result_data.get("preserved_terms", [])
        )
    
    def _build_system_prompt(self, request: TranslationRequest, target_lang: TargetLanguage) -> str:
        """Construye el prompt del sistema para traducci√≥n"""
        
        target_lang_name = self.language_names[target_lang]
        content_style = self.content_type_instructions[request.content_type]
        
        return f"""
        Eres un traductor profesional especializado en {content_style} para marcas de lujo internacionales.

        ESPECIALIZACI√ìN:
        - Traducci√≥n de espa√±ol a {target_lang_name}
        - Adaptaci√≥n cultural para mercados de lujo
        - Preservaci√≥n de t√©rminos de marca espec√≠ficos
        - Mantenimiento del tono y estilo original

        DIRECTRICES:
        1. PRECISI√ìN: Traduce manteniendo el significado exacto
        2. ESTILO: Conserva el tono {content_style}
        3. CULTURA: Adapta expresiones al mercado local
        4. MARCA: Preserva t√©rminos espec√≠ficos de marca
        5. NATURALIDAD: El texto debe sonar nativo

        FORMATO DE RESPUESTA (JSON):
        {{
            "translated_text": "Traducci√≥n completa y natural",
            "cultural_notes": ["Nota 1 sobre adaptaci√≥n", "Nota 2"],
            "preserved_terms": ["t√©rmino1", "t√©rmino2"]
        }}

        REGLAS ESPEC√çFICAS PARA {target_lang_name.upper()}:
        {self._get_language_specific_rules(target_lang)}
        """
    
    def _get_language_specific_rules(self, target_lang: TargetLanguage) -> str:
        """Reglas espec√≠ficas por idioma"""
        
        rules = {
            TargetLanguage.ENGLISH: """
            - Usa vocabulario sofisticado pero accesible
            - Prefiere "luxury" sobre "luxurious" para productos
            - Usa "exclusive" con moderaci√≥n
            - Adapta medidas al sistema imperial cuando sea natural
            """,
            
            TargetLanguage.FRENCH: """
            - Mant√©n la elegancia del franc√©s sin ser pretencioso
            - Usa "de luxe" o "haut de gamme" apropiadamente
            - Respeta las reglas de g√©nero y concordancia
            - Adapta expresiones de cortes√≠a francesa
            """,
            
            TargetLanguage.ITALIAN: """
            - Enfatiza la pasi√≥n y elegancia italiana
            - Usa "di lusso" o "esclusivo" seg√∫n contexto
            - Mant√©n la musicalidad del italiano
            - Adapta expresiones de hospitalidad italiana
            """,
            
            TargetLanguage.GERMAN: """
            - Usa palabras compuestas cuando sea natural
            - Mant√©n la precisi√≥n alemana en descripciones t√©cnicas
            - "Luxus" o "exklusiv" seg√∫n corresponda
            - Adapta al estilo directo alem√°n
            """,
            
            TargetLanguage.PORTUGUESE: """
            - Distingue entre portugu√©s de Brasil y Portugal seg√∫n mercado
            - Usa "de luxo" o "exclusivo" apropiadamente
            - Mant√©n la calidez del portugu√©s
            - Adapta expresiones de hospitalidad lus√≥fona
            """,
            
            TargetLanguage.CATALAN: """
            - Usa catal√°n est√°ndar contempor√°neo
            - "De luxe" o "exclusiu" seg√∫n contexto
            - Mant√©n naturalidad sin calcos del espa√±ol
            - Adapta a la cultura catalana
            """
        }
        
        return rules.get(target_lang, "Aplica mejores pr√°cticas de traducci√≥n.")
    
    def _build_user_prompt(self, request: TranslationRequest, target_lang: TargetLanguage) -> str:
        """Construye el prompt del usuario"""
        
        preserved_terms_text = ", ".join(request.preserve_brand_terms) if request.preserve_brand_terms else "Ninguno"
        target_lang_name = self.language_names[target_lang]
        
        return f"""
        TEXTO A TRADUCIR AL {target_lang_name.upper()}:
        "{request.source_text}"

        CONTEXTO:
        - Marca: {request.brand_name}
        - Tipo de contenido: {request.content_type.value}
        - T√©rminos a preservar: {preserved_terms_text}
        - Adaptaci√≥n cultural: {"S√≠" if request.cultural_adaptation else "No"}

        INSTRUCCIONES:
        1. Traduce el texto completo manteniendo el impacto emocional
        2. Adapta culturalmente para el mercado {target_lang_name}
        3. Preserva los t√©rminos de marca especificados
        4. Proporciona notas sobre adaptaciones culturales realizadas
        5. Responde SOLO en formato JSON v√°lido

        ¬°Traduce ahora!
        """
    
    def _parse_translation_response(self, raw_response: str) -> dict:
        """Parsea la respuesta de traducci√≥n"""
        try:
            # Extraer JSON de la respuesta
            import re
            json_match = re.search(r'\{.*\}', raw_response, re.DOTALL)
            
            if json_match:
                json_str = json_match.group()
                return json.loads(json_str)
            else:
                # Fallback si no hay JSON v√°lido
                return {
                    "translated_text": raw_response.strip(),
                    "cultural_notes": [],
                    "preserved_terms": []
                }
                
        except json.JSONDecodeError:
            # Fallback en caso de error
            return {
                "translated_text": raw_response.strip(),
                "cultural_notes": ["Error parsing response"],
                "preserved_terms": []
            }

# Instancia global
translation_agent = TranslationAgent()
```

### üåê API Endpoint para Traducci√≥n
```python
# api_translation.py
from fastapi import FastAPI, HTTPException
from translation_models import TranslationRequest, TranslationResponse
from translation_agent import translation_agent
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="API Traductor Especializado",
    description="API de traducci√≥n cultural para contenido de marketing de lujo",
    version="1.0.0"
)

@app.post("/translate", response_model=TranslationResponse)
async def translate_content(request: TranslationRequest):
    """
    Traduce contenido a m√∫ltiples idiomas con adaptaci√≥n cultural.
    
    Especializado en:
    - Marketing de lujo
    - Contenido hotelero
    - Bienes de lujo
    - Adaptaci√≥n cultural por mercado
    """
    try:
        logger.info(f"Iniciando traducci√≥n a {len(request.target_languages)} idiomas")
        
        response = await translation_agent.translate_content(request)
        
        logger.info(f"Traducci√≥n completada en {response.processing_time}s")
        return response
        
    except Exception as e:
        logger.error(f"Error en traducci√≥n: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """Health check del servicio de traducci√≥n"""
    return {"status": "healthy", "service": "translation-service"}

@app.get("/supported-languages")
async def get_supported_languages():
    """Lista de idiomas soportados"""
    return {
        "languages": [
            {"code": "en", "name": "English"},
            {"code": "fr", "name": "Fran√ßais"},
            {"code": "it", "name": "Italiano"},
            {"code": "de", "name": "Deutsch"},
            {"code": "pt", "name": "Portugu√™s"},
            {"code": "ca", "name": "Catal√†"}
        ]
    }

if __name__ == "__main__":
    import uvicorn
    from config import settings
    
    uvicorn.run(
        "api_translation:app", 
        host=settings.API_HOST, 
        port=8002,  # Puerto espec√≠fico para traducci√≥n
        reload=True
    )
```

---

## 5. Sistema Integrado: Orquestador

### üéº Cliente que Consume Ambas APIs
```python
# integrated_client.py
import httpx
import asyncio
from typing import List, Dict
from models import ProductSpecs, MarketingRequest, ProductType
from translation_models import TranslationRequest, ContentType, TargetLanguage

class IntegratedMarketingClient:
    """Cliente que orquesta ambas APIs para generar contenido multiidioma"""
    
    def __init__(self, marketing_url: str = "http://localhost:8001", translation_url: str = "http://localhost:8002"):
        self.marketing_url = marketing_url
        self.translation_url = translation_url
    
    async def generate_multilingual_marketing(
        self,
        product: ProductSpecs,
        target_languages: List[TargetLanguage],
        brand_name: str = "Luxury Brand"
    ) -> Dict:
        """Genera marketing completo en m√∫ltiples idiomas"""
        
        async with httpx.AsyncClient() as client:
            # Paso 1: Generar descripci√≥n de marketing
            marketing_request = MarketingRequest(
                product=product,
                style="luxury",
                tone="elegant",
                max_words=150
            )
            
            marketing_response = await client.post(
                f"{self.marketing_url}/generate-marketing",
                json=marketing_request.dict()
            )
            
            if marketing_response.status_code != 200:
                raise Exception(f"Error en API de marketing: {marketing_response.text}")
            
            marketing_data = marketing_response.json()
            
            # Paso 2: Traducir contenido generado
            translation_request = TranslationRequest(
                source_text=marketing_data["description"],
                target_languages=target_languages,
                content_type=self._map_product_type_to_content_type(product.type),
                brand_name=brand_name,
                cultural_adaptation=True
            )
            
            translation_response = await client.post(
                f"{self.translation_url}/translate",
                json=translation_request.dict()
            )
            
            if translation_response.status_code != 200:
                raise Exception(f"Error en API de traducci√≥n: {translation_response.text}")
            
            translation_data = translation_response.json()
            
            # Combinar resultados
            return {
                "original_marketing": marketing_data,
                "translations": translation_data,
                "summary": {
                    "product_name": product.name,
                    "languages_generated": len(target_languages),
                    "total_processing_time": translation_data["processing_time"]
                }
            }
    
    def _map_product_type_to_content_type(self, product_type: ProductType) -> ContentType:
        """Mapea tipo de producto a tipo de contenido para traducci√≥n"""
        mapping = {
            ProductType.HOTEL_SERVICE: ContentType.HOSPITALITY,
            ProductType.HOTEL_AMENITY: ContentType.HOSPITALITY,
            ProductType.SPA_SERVICE: ContentType.HOSPITALITY,
            ProductType.LUXURY_WATCH: ContentType.LUXURY_GOODS,
            ProductType.JEWELRY: ContentType.LUXURY_GOODS
        }
        return mapping.get(product_type, ContentType.MARKETING)

# Funci√≥n helper para testing
async def test_integrated_flow():
    """Test del flujo completo"""
    
    # Definir producto de ejemplo
    product = ProductSpecs(
        name="Suite Presidencial Barcelona",
        type=ProductType.HOTEL_SERVICE,
        category="Alojamiento Premium",
        features=[
            "Vista panor√°mica de la ciudad",
            "Terraza privada de 50m¬≤", 
            "Servicio de mayordomo 24h",
            "Mobiliario de dise√±o exclusivo"
        ],
        price_range="‚Ç¨800-1200/noche",
        target_audience="Ejecutivos internacionales y viajeros de lujo",
        unique_selling_points=[
            "√önica suite con terraza en el centro hist√≥rico",
            "Dise√±o personalizado por arquitecto reconocido",
            "Acceso VIP a servicios del hotel"
        ]
    )
    
    # Idiomas objetivo
    target_languages = [
        TargetLanguage.ENGLISH,
        TargetLanguage.FRENCH,
        TargetLanguage.ITALIAN
    ]
    
    # Generar contenido
    client = IntegratedMarketingClient()
    
    try:
        result = await client.generate_multilingual_marketing(
            product=product,
            target_languages=target_languages,
            brand_name="Hotel Barcelona Luxury"
        )
        
        print("üéâ ¬°Contenido generado exitosamente!")
        print(f"üìù Producto: {result['summary']['product_name']}")
        print(f"üåç Idiomas: {result['summary']['languages_generated']}")
        print(f"‚è±Ô∏è Tiempo total: {result['summary']['total_processing_time']}s")
        
        return result
        
    except Exception as e:
        print(f"‚ùå Error: {str(e)}")
        return None

if __name__ == "__main__":
    asyncio.run(test_integrated_flow())
```

---

## 6. Scripts de Ejecuci√≥n

### üöÄ Lanzador de Servicios
```python
# run_services.py
import subprocess
import time
import sys
from multiprocessing import Process

def start_marketing_api():
    """Inicia API de marketing"""
    subprocess.run([
        sys.executable, "api_marketing.py"
    ])

def start_translation_api():
    """Inicia API de traducci√≥n"""
    subprocess.run([
        sys.executable, "api_translation.py" 
    ])

def main():
    """Lanza ambos servicios"""
    print("üöÄ Iniciando servicios de Marketing Multiidioma...")
    
    # Crear procesos
    marketing_process = Process(target=start_marketing_api)
    translation_process = Process(target=start_translation_api)
    
    try:
        # Iniciar servicios
        print("üìù Iniciando API de Marketing en puerto 8001...")
        marketing_process.start()
        
        time.sleep(2)  # Esperar un momento
        
        print("üåç Iniciando API de Traducci√≥n en puerto 8002...")
        translation_process.start()
        
        print("‚úÖ Ambos servicios iniciados correctamente!")
        print("üìñ Documentaci√≥n disponible en:")
        print("   - Marketing: http://localhost:8001/docs")
        print("   - Traducci√≥n: http://localhost:8002/docs")
        
        # Mantener vivos los procesos
        marketing_process.join()
        translation_process.join()
        
    except KeyboardInterrupt:
        print("\nüõë Deteniendo servicios...")
        marketing_process.terminate()
        translation_process.terminate()
        marketing_process.join()
        translation_process.join()
        print("‚úÖ Servicios detenidos correctamente")

if __name__ == "__main__":
    main()
```

### üß™ Script de Testing
```python
# test_apis.py
import asyncio
import json
from integrated_client import test_integrated_flow, IntegratedMarketingClient
from models import ProductSpecs, ProductType
from translation_models import TargetLanguage

async def test_watch_example():
    """Test con reloj de lujo"""
    
    watch_product = ProductSpecs(
        name="Rolex Submariner Edici√≥n Barcelona",
        type=ProductType.LUXURY_WATCH,
        category="Relojer√≠a Deportiva de Lujo",
        features=[
            "Movimiento autom√°tico suizo",
            "Resistente al agua hasta 300m",
            "Bisel giratorio unidireccional",
            "Cristal de zafiro antireflejo"
        ],
        materials=["Acero inoxidable 904L", "Oro amarillo 18k", "Cristal de zafiro"],
        price_range="‚Ç¨15,000-25,000",
        target_audience="Coleccionistas y entusiastas de la relojer√≠a",
        unique_selling_points=[
            "Edici√≥n limitada exclusiva para Barcelona",
            "Grabado personalizado de la ciudad",
            "Certificado de autenticidad numerado"
        ]
    )
    
    client = IntegratedMarketingClient()
    
    result = await client.generate_multilingual_marketing(
        product=watch_product,
        target_languages=[TargetLanguage.ENGLISH, TargetLanguage.FRENCH],
        brand_name="Relojer√≠a Barcelona Premium"
    )
    
    if result:
        print("\n" + "="*60)
        print("üïí MARKETING DE RELOJ GENERADO")
        print("="*60)
        
        # Marketing original
        marketing = result["original_marketing"]
        print(f"\nüìù T√çTULO: {marketing['title']}")
        print(f"\nüìÑ DESCRIPCI√ìN: {marketing['description']}")
        print(f"\n‚ú® BENEFICIOS CLAVE:")
        for benefit in marketing['key_benefits']:
            print(f"   ‚Ä¢ {benefit}")
        print(f"\nüéØ CALL TO ACTION: {marketing['call_to_action']}")
        
        # Traducciones
        print(f"\nüåç TRADUCCIONES:")
        for translation in result["translations"]["translations"]:
            print(f"\nüá¨üáß {translation['language'].upper()}:")
            print(f"   {translation['translated_text']}")
            
            if translation['cultural_notes']:
                print(f"   üìå Notas culturales:")
                for note in translation['cultural_notes']:
                    print(f"      ‚Ä¢ {note}")

async def main():
    """Ejecuta todos los tests"""
    print("üß™ Iniciando tests de APIs integradas...")
    
    # Test 1: Flujo completo hotel
    print("\n1Ô∏è‚É£ Test: Suite de Hotel")
    await test_integrated_flow()
    
    # Test 2: Reloj de lujo  
    print("\n2Ô∏è‚É£ Test: Reloj de Lujo")
    await test_watch_example()
    
    print("\n‚úÖ Tests completados!")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## 7. Ejercicio Pr√°ctico

### üéØ **Para la Clase**

1. **Setup inicial** (10 min):
   - Configurar `.env` con API key de OpenAI
   - Instalar dependencias
   - Verificar conexi√≥n API

2. **Demo de API 1** (15 min):
   - Mostrar generaci√≥n de marketing para un producto del hotel
   - Explicar especializaci√≥n por tipo de producto
   - Testing en vivo con diferentes inputs

3. **Demo de API 2** (15 min):
   - Traducir contenido generado a 2-3 idiomas
   - Mostrar adaptaci√≥n cultural
   - Comparar calidad vs traducciones autom√°ticas

4. **Integraci√≥n** (10 min):
   - Ejecutar flujo completo desde SAP simulado
   - Mostrar resultado final multiidioma
   - Discutir escalabilidad y producci√≥n

### üèÉ‚Äç‚ôÇÔ∏è **Hands-on para Participantes**

Crear su propio producto y generar marketing en 3 idiomas:

```python
# Su producto aqu√≠
mi_producto = ProductSpecs(
    name="[SU PRODUCTO]",
    type=ProductType.HOTEL_SERVICE,  # o el que corresponda
    category="[CATEGOR√çA]",
    features=["Caracter√≠stica 1", "Caracter√≠stica 2"],
    target_audience="[SU P√öBLICO]",
    unique_selling_points=["USP 1", "USP 2"]
)
```

¬øTe parece bien este enfoque? Las "2 APIs" se refieren exactamente a esta arquitectura de microservicios especializados que pueden trabajar independientemente o en conjunto. ¬øQuieres que ajuste alg√∫n aspecto espec√≠fico del ejercicio?
