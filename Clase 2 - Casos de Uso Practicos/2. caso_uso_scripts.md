# Caso de Uso 2: Scripts de GestiÃ³n de Sistemas
## De DescripciÃ³n Natural a AutomatizaciÃ³n Completa

### ğŸ¯ Objetivo
Transformar requerimientos en lenguaje natural ("Quiero un script que...") en scripts funcionales para gestiÃ³n de infraestructura de red y sistemas, utilizando GitHub Copilot.

### ğŸ“‹ Escenario Real
**Requerimiento del Cliente**:
> "Quiero un script que recorra todos los equipos Cisco de este Excel, se conecte a cada uno de ellos y extraiga la versiÃ³n de iOS"

**Contexto**: Hotel de lujo + relojerÃ­a con infraestructura de red compleja:
- 50+ equipos Cisco (switches, routers, APs)
- Necesidad de auditorÃ­a automÃ¡tica
- Requerimientos de cumplimiento y seguridad

### ğŸ› ï¸ Demo en Vivo: Script Cisco desde Cero

#### **Paso 1: AnÃ¡lisis del Requerimiento**

**Prompt inicial para GitHub Copilot**:
```
Necesito crear un script en Python que:

1. Lea un archivo Excel con equipos Cisco (IP, usuario, contraseÃ±a, tipo)
2. Se conecte via SSH a cada equipo
3. Ejecute comando para obtener versiÃ³n de iOS
4. Genere un reporte Excel con los resultados
5. Maneje errores de conexiÃ³n y timeout
6. Incluya logging detallado

El script debe ser robusto y fÃ¡cil de usar por personal no tÃ©cnico.
Â¿Puedes generar la estructura completa del script?
```

#### **Paso 2: Desarrollo Iterativo**

**Prompt para estructura inicial**:
```python
# Script generado por GitHub Copilot
# GestiÃ³n automÃ¡tica de equipos Cisco para Hotel de Lujo

import pandas as pd
import paramiko
import logging
from datetime import datetime
import sys
import os
from typing import Dict, List, Tuple

class CiscoDeviceManager:
    """Gestor para conectar y extraer informaciÃ³n de equipos Cisco"""
    
    def __init__(self, excel_file: str, output_file: str = None):
        self.excel_file = excel_file
        self.output_file = output_file or f"cisco_audit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        self.results = []
        self.setup_logging()
    
    def setup_logging(self):
        """Configura el sistema de logging"""
        log_filename = f"cisco_audit_{datetime.now().strftime('%Y%m%d')}.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_filename),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
```

**Prompt para mÃ©todo de conexiÃ³n**:
```
Agrega el mÃ©todo para conectar via SSH a un equipo Cisco y ejecutar comandos. 
Debe manejar:
- Timeout de conexiÃ³n (30 segundos)
- AutenticaciÃ³n con usuario/contraseÃ±a
- Comandos especÃ­ficos de Cisco IOS
- Captura de output limpio
- Manejo de errores de red
- Cleanup de conexiones
```

#### **Paso 3: Excel de Ejemplo**

Creamos un archivo Excel de ejemplo con la estructura:

| IP Address    | Hostname        | Device Type | Username | Password   | Location      |
|---------------|-----------------|-------------|----------|------------|---------------|
| 192.168.1.10  | SW-RECEPTION-01 | Switch      | admin    | hotel2024  | RecepciÃ³n     |
| 192.168.1.20  | RTR-MAIN-01     | Router      | admin    | hotel2024  | Sala TÃ©cnica  |
| 192.168.2.10  | AP-LOBBY-01     | Access Point| admin    | hotel2024  | Lobby         |
| 192.168.3.15  | SW-SPA-01       | Switch      | admin    | hotel2024  | Spa           |

### ğŸ“ Ejercicio Hands-On: Script Personalizado

#### **DesafÃ­o**: Cada participante desarrollarÃ¡ un script basado en necesidades especÃ­ficas:

**Opciones de ejercicio**:
1. **Auditoria de seguridad**: Verificar configuraciones de seguridad
2. **Monitoreo de performance**: Extraer mÃ©tricas de CPU/memoria
3. **Backup de configuraciones**: Descargar running-config
4. **Inventory management**: Crear inventario actualizado

#### **Script Base Completo**:

```python
#!/usr/bin/env python3
"""
Script de GestiÃ³n de Equipos Cisco
Desarrollado con GitHub Copilot para Hotel de Lujo

Funcionalidades:
- Lectura de inventario desde Excel
- ConexiÃ³n SSH automÃ¡tica
- ExtracciÃ³n de informaciÃ³n del sistema
- GeneraciÃ³n de reportes
- Logging completo
"""

import pandas as pd
import paramiko
import logging
import socket
import time
from datetime import datetime
from pathlib import Path
import sys
from typing import Dict, List, Optional, Tuple

class CiscoAuditTool:
    """Herramienta completa para auditorÃ­a de equipos Cisco"""
    
    def __init__(self, excel_file: str, output_dir: str = "reports"):
        self.excel_file = Path(excel_file)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # Configurar archivos de salida
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.report_file = self.output_dir / f"cisco_audit_{timestamp}.xlsx"
        self.log_file = self.output_dir / f"audit_log_{timestamp}.log"
        
        self.devices = []
        self.results = []
        self.failed_devices = []
        
        self.setup_logging()
        self.ssh_timeout = 30
        self.command_timeout = 10
    
    def setup_logging(self):
        """Configura el sistema de logging detallado"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger('CiscoAudit')
    
    def load_devices(self) -> bool:
        """Carga la lista de dispositivos desde Excel"""
        try:
            self.logger.info(f"Cargando dispositivos desde {self.excel_file}")
            df = pd.read_excel(self.excel_file)
            
            # Validar columnas requeridas
            required_columns = ['IP Address', 'Username', 'Password']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                self.logger.error(f"Columnas faltantes en Excel: {missing_columns}")
                return False
            
            self.devices = df.to_dict('records')
            self.logger.info(f"Cargados {len(self.devices)} dispositivos")
            return True
            
        except Exception as e:
            self.logger.error(f"Error cargando Excel: {str(e)}")
            return False
    
    def connect_to_device(self, device: Dict) -> Optional[paramiko.SSHClient]:
        """Establece conexiÃ³n SSH con un dispositivo"""
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        try:
            self.logger.info(f"Conectando a {device['IP Address']}")
            
            ssh.connect(
                hostname=device['IP Address'],
                username=device['Username'],
                password=device['Password'],
                timeout=self.ssh_timeout,
                look_for_keys=False,
                allow_agent=False
            )
            
            return ssh
            
        except socket.timeout:
            self.logger.error(f"Timeout conectando a {device['IP Address']}")
        except paramiko.AuthenticationException:
            self.logger.error(f"Error de autenticaciÃ³n en {device['IP Address']}")
        except Exception as e:
            self.logger.error(f"Error conectando a {device['IP Address']}: {str(e)}")
        
        return None
    
    def execute_command(self, ssh: paramiko.SSHClient, command: str) -> Optional[str]:
        """Ejecuta un comando en el dispositivo y retorna el output"""
        try:
            stdin, stdout, stderr = ssh.exec_command(command, timeout=self.command_timeout)
            output = stdout.read().decode('utf-8').strip()
            error = stderr.read().decode('utf-8').strip()
            
            if error:
                self.logger.warning(f"Error en comando '{command}': {error}")
            
            return output
            
        except Exception as e:
            self.logger.error(f"Error ejecutando comando '{command}': {str(e)}")
            return None
    
    def extract_ios_version(self, output: str) -> Dict[str, str]:
        """Extrae informaciÃ³n de versiÃ³n del output del comando show version"""
        info = {
            'ios_version': 'N/A',
            'device_model': 'N/A',
            'uptime': 'N/A',
            'serial_number': 'N/A'
        }
        
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Extraer versiÃ³n IOS
            if 'Cisco IOS Software' in line or 'IOS-XE Software' in line:
                parts = line.split(',')
                if len(parts) > 1:
                    info['ios_version'] = parts[1].strip()
            
            # Extraer modelo
            if 'cisco' in line.lower() and ('router' in line.lower() or 'switch' in line.lower()):
                info['device_model'] = line.strip()
            
            # Extraer uptime
            if 'uptime is' in line.lower():
                info['uptime'] = line.split('uptime is')[1].strip()
            
            # Extraer serial
            if 'Processor board ID' in line:
                info['serial_number'] = line.split('Processor board ID')[1].strip()
        
        return info
    
    def audit_device(self, device: Dict) -> Dict:
        """Audita un dispositivo individual"""
        result = {
            'IP Address': device['IP Address'],
            'Hostname': device.get('Hostname', 'N/A'),
            'Location': device.get('Location', 'N/A'),
            'Status': 'Failed',
            'Error': '',
            'Timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        ssh = self.connect_to_device(device)
        if not ssh:
            result['Error'] = 'ConexiÃ³n fallida'
            return result
        
        try:
            # Ejecutar comando show version
            output = self.execute_command(ssh, 'show version')
            if output:
                # Extraer informaciÃ³n
                ios_info = self.extract_ios_version(output)
                result.update(ios_info)
                result['Status'] = 'Success'
                
                self.logger.info(f"Auditoria exitosa: {device['IP Address']} - {ios_info['ios_version']}")
            else:
                result['Error'] = 'Sin respuesta del comando'
        
        except Exception as e:
            result['Error'] = str(e)
            self.logger.error(f"Error auditando {device['IP Address']}: {str(e)}")
        
        finally:
            ssh.close()
        
        return result
    
    def run_audit(self) -> bool:
        """Ejecuta la auditorÃ­a completa"""
        if not self.load_devices():
            return False
        
        self.logger.info("Iniciando auditorÃ­a de dispositivos Cisco")
        start_time = datetime.now()
        
        for i, device in enumerate(self.devices, 1):
            self.logger.info(f"Procesando dispositivo {i}/{len(self.devices)}: {device['IP Address']}")
            
            result = self.audit_device(device)
            self.results.append(result)
            
            if result['Status'] == 'Failed':
                self.failed_devices.append(device['IP Address'])
            
            # PequeÃ±a pausa entre conexiones
            time.sleep(1)
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        self.logger.info(f"AuditorÃ­a completada en {duration:.2f} segundos")
        self.logger.info(f"Dispositivos exitosos: {len(self.results) - len(self.failed_devices)}")
        self.logger.info(f"Dispositivos fallidos: {len(self.failed_devices)}")
        
        return self.generate_report()
    
    def generate_report(self) -> bool:
        """Genera el reporte Excel con los resultados"""
        try:
            # Crear DataFrame con resultados
            df_results = pd.DataFrame(self.results)
            
            # Crear resumen
            summary_data = {
                'Metric': [
                    'Total Devices',
                    'Successful Audits',
                    'Failed Audits',
                    'Success Rate (%)',
                    'Audit Date'
                ],
                'Value': [
                    len(self.devices),
                    len(self.results) - len(self.failed_devices),
                    len(self.failed_devices),
                    round(((len(self.results) - len(self.failed_devices)) / len(self.devices)) * 100, 2),
                    datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                ]
            }
            df_summary = pd.DataFrame(summary_data)
            
            # Escribir Excel con mÃºltiples hojas
            with pd.ExcelWriter(self.report_file, engine='openpyxl') as writer:
                df_summary.to_excel(writer, sheet_name='Summary', index=False)
                df_results.to_excel(writer, sheet_name='Detailed Results', index=False)
                
                if self.failed_devices:
                    df_failed = pd.DataFrame({'Failed_IP': self.failed_devices})
                    df_failed.to_excel(writer, sheet_name='Failed Devices', index=False)
            
            self.logger.info(f"Reporte generado: {self.report_file}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error generando reporte: {str(e)}")
            return False

def main():
    """FunciÃ³n principal"""
    print("ğŸ”§ Herramienta de AuditorÃ­a Cisco - Hotel de Lujo")
    print("=" * 50)
    
    # Solicitar archivo Excel
    excel_file = input("Ingrese la ruta del archivo Excel con dispositivos: ").strip()
    
    if not Path(excel_file).exists():
        print(f"âŒ Error: El archivo {excel_file} no existe")
        return
    
    # Crear instancia y ejecutar auditorÃ­a
    audit_tool = CiscoAuditTool(excel_file)
    
    print("\nğŸš€ Iniciando auditorÃ­a...")
    success = audit_tool.run_audit()
    
    if success:
        print(f"\nâœ… AuditorÃ­a completada exitosamente!")
        print(f"ğŸ“Š Reporte generado: {audit_tool.report_file}")
        print(f"ğŸ“ Log disponible: {audit_tool.log_file}")
    else:
        print("\nâŒ Error durante la auditorÃ­a")

if __name__ == "__main__":
    main()
```

### ğŸ“‹ Plantillas de Prompts para Scripts

#### **Para AnÃ¡lisis de Requerimientos**:
```
Analiza este requerimiento de automatizaciÃ³n y descompÃ³nlo en:

1. **Inputs necesarios** (archivos, parÃ¡metros, credenciales)
2. **Procesamiento requerido** (conexiones, comandos, lÃ³gica)
3. **Outputs esperados** (reportes, logs, alertas)
4. **Manejo de errores** (timeouts, fallos de conexiÃ³n, permisos)
5. **Consideraciones de seguridad** (credenciales, logs, acceso)
6. **Usabilidad** (interfaz, mensajes, documentaciÃ³n)

Requerimiento: [PEGAR DESCRIPCIÃ“N AQUÃ]
```

#### **Para Desarrollo de Scripts**:
```
Genera un script de Python profesional que:

âœ… **Funcionalidad**: [descripciÃ³n especÃ­fica]
âœ… **Inputs**: [archivos/parÃ¡metros de entrada]
âœ… **Outputs**: [reportes/archivos de salida]
âœ… **Error handling**: Manejo robusto de errores
âœ… **Logging**: Sistema de logs detallado
âœ… **DocumentaciÃ³n**: Docstrings y comentarios
âœ… **Usabilidad**: Interfaz clara para usuarios no tÃ©cnicos
âœ… **Configurabilidad**: ParÃ¡metros ajustables
âœ… **Escalabilidad**: CÃ³digo modular y reutilizable

LibrerÃ­as preferidas: pandas, paramiko, logging, pathlib
Estilo: PEP 8 compliant, type hints, clases cuando apropiado
```

#### **Para OptimizaciÃ³n**:
```
Revisa este script y sugiere mejoras en:

1. **Performance**: Optimizaciones de velocidad
2. **Memoria**: Uso eficiente de recursos
3. **Seguridad**: Mejores prÃ¡cticas de seguridad
4. **Mantenibilidad**: CÃ³digo mÃ¡s limpio y modular
5. **Robustez**: Mejor manejo de errores
6. **Usabilidad**: Interfaz mÃ¡s amigable
7. **Testing**: Estrategias de testing

[PEGAR CÃ“DIGO AQUÃ]
```

### ğŸ¯ Casos de Uso Adicionales

#### **1. Backup AutomÃ¡tico de Configuraciones**
```
Script que:
- Conecte a equipos de red
- Descargue running-config y startup-config
- Los almacene con timestamp
- Compare con versiones anteriores
- EnvÃ­e alertas por cambios crÃ­ticos
```

#### **2. Monitoreo de Health Status**
```
Script que:
- Verifique CPU, memoria, temperatura
- Valide conectividad de interfaces
- Revise logs de errores recientes
- Genere dashboard de salud general
- EnvÃ­e alertas proactivas
```

#### **3. GestiÃ³n de VLANs**
```
Script que:
- Audite configuraciÃ³n de VLANs
- Verifique consistencia entre switches
- Identifique VLANs huÃ©rfanas
- Documente topologÃ­a de red
- Sugiera optimizaciones
```

### ğŸ“Š Ejercicio Final: Script Personalizado

**Tiempo**: 25 minutos

**Instrucciones**:
1. **Elegir un caso de uso** especÃ­fico para su organizaciÃ³n
2. **Definir requerimientos** en lenguaje natural
3. **Usar GitHub Copilot** para generar el script
4. **Iterar y mejorar** basado en feedback del Copilot
5. **Documentar** el script para futura referencia

**Entregables**:
- âœ… Script funcional completo
- âœ… Archivo Excel de ejemplo
- âœ… DocumentaciÃ³n de uso
- âœ… Plan de implementaciÃ³n

### ğŸ’¡ Tips para Maximizar Efectividad

#### **Prompting Efectivo**:
- ğŸ¯ **SÃ© especÃ­fico** sobre el entorno (Cisco, Python, Excel)
- ğŸ“ **Incluye contexto** del negocio (hotel, seguridad, auditorÃ­a)
- ğŸ”„ **Itera gradualmente** construyendo funcionalidad
- ğŸ›¡ï¸ **Enfatiza robustez** y manejo de errores

#### **Mejores PrÃ¡cticas**:
- ğŸ“š **Modulariza** el cÃ³digo desde el inicio
- ğŸ” **Valida inputs** antes del procesamiento
- ğŸ“± **Considera mÃºltiples escenarios** de error
- ğŸ¨ **Piensa en el usuario final** no tÃ©cnico

### ğŸ† Criterios de Ã‰xito

Al finalizar, cada participante habrÃ¡:

1. **ğŸ¯ Transformado requerimientos** naturales en cÃ³digo funcional
2. **âš¡ Automatizado tareas** que tomaban horas en minutos
3. **ğŸ› ï¸ Creado herramientas** reutilizables para su equipo
4. **ğŸ“Š Generado reportes** profesionales automÃ¡ticamente
5. **ğŸ”§ Aplicado mejores prÃ¡cticas** de desarrollo y seguridad

**Tiempo total ahorrado por script**: 2-4 horas por ejecuciÃ³n
**ROI estimado**: 300-500% en el primer mes