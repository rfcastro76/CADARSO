# Caso de Uso 2: Scripts de Gesti√≥n de Sistemas
## De Descripci√≥n Natural a Automatizaci√≥n Completa

### üéØ Objetivo
Transformar requerimientos en lenguaje natural ("Quiero un script que...") en scripts funcionales para gesti√≥n de infraestructura de red y sistemas, utilizando GitHub Copilot.

### üìã Escenario Real
**Requerimiento del Cliente**:
> "Quiero un script que recorra todos los equipos Cisco de este Excel, se conecte a cada uno de ellos y extraiga la versi√≥n de iOS"

**Contexto**: Hotel de lujo + relojer√≠a con infraestructura de red compleja:
- 50+ equipos Cisco (switches, routers, APs)
- Necesidad de auditor√≠a autom√°tica
- Requerimientos de cumplimiento y seguridad

### üõ†Ô∏è Demo en Vivo: Script Cisco desde Cero

#### **Paso 1: An√°lisis del Requerimiento**

**Prompt inicial para GitHub Copilot**:
```
Necesito crear un script en Python que:

1. Lea un archivo Excel con equipos Cisco (IP, usuario, contrase√±a, tipo)
2. Se conecte via SSH a cada equipo
3. Ejecute comando para obtener versi√≥n de iOS
4. Genere un reporte Excel con los resultados
5. Maneje errores de conexi√≥n y timeout
6. Incluya logging detallado

El script debe ser robusto y f√°cil de usar por personal no t√©cnico.
¬øPuedes generar la estructura completa del script?
```

#### **Paso 2: Desarrollo Iterativo**

**Prompt para estructura inicial**:
```python
# Script generado por GitHub Copilot
# Gesti√≥n autom√°tica de equipos Cisco para Hotel de Lujo

import pandas as pd
import paramiko
import logging
from datetime import datetime
import sys
import os
from typing import Dict, List, Tuple

class CiscoDeviceManager:
    """Gestor para conectar y extraer informaci√≥n de equipos Cisco"""
    
    def __init__(self, excel_file: str, output_file: str = None):
        self.excel_file = excel_file
        self.output_file = output_file or f"cisco_audit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        self.results = []
        self.setup_logging()
    
    def setup_logging(self):
        """Configura el sistema de logging"""
        log_filename = f"cisco_audit_{datetime.now().strftime('%Y%m%d')}.log"
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_filename),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger(__name__)
```

**Prompt para m√©todo de conexi√≥n**:
```
Agrega el m√©todo para conectar via SSH a un equipo Cisco y ejecutar comandos. 
Debe manejar:
- Timeout de conexi√≥n (30 segundos)
- Autenticaci√≥n con usuario/contrase√±a
- Comandos espec√≠ficos de Cisco IOS
- Captura de output limpio
- Manejo de errores de red
- Cleanup de conexiones
```

#### **Paso 3: Excel de Ejemplo**

Creamos un archivo Excel de ejemplo con la estructura:

| IP Address    | Hostname        | Device Type | Username | Password   | Location      |
|---------------|-----------------|-------------|----------|------------|---------------|
| 192.168.1.10  | SW-RECEPTION-01 | Switch      | admin    | hotel2024  | Recepci√≥n     |
| 192.168.1.20  | RTR-MAIN-01     | Router      | admin    | hotel2024  | Sala T√©cnica  |
| 192.168.2.10  | AP-LOBBY-01     | Access Point| admin    | hotel2024  | Lobby         |
| 192.168.3.15  | SW-SPA-01       | Switch      | admin    | hotel2024  | Spa           |

### üéì Ejercicio Hands-On: Script Personalizado

#### **Desaf√≠o**: Cada participante desarrollar√° un script basado en necesidades espec√≠ficas:

**Opciones de ejercicio**:
1. **Auditoria de seguridad**: Verificar configuraciones de seguridad
2. **Monitoreo de performance**: Extraer m√©tricas de CPU/memoria
3. **Backup de configuraciones**: Descargar running-config
4. **Inventory management**: Crear inventario actualizado

#### **Script Base Completo**:

```python
#!/usr/bin/env python3
"""
Script de Gesti√≥n de Equipos Cisco
Desarrollado con GitHub Copilot para Hotel de Lujo

Funcionalidades:
- Lectura de inventario desde Excel
- Conexi√≥n SSH autom√°tica
- Extracci√≥n de informaci√≥n del sistema
- Generaci√≥n de reportes
- Logging completo
"""

import pandas as pd
import paramiko
import logging
import socket
import time
from datetime import datetime
from pathlib import Path
import sys
from typing import Dict, List, Optional, Tuple

class CiscoAuditTool:
    """Herramienta completa para auditor√≠a de equipos Cisco"""
    
    def __init__(self, excel_file: str, output_dir: str = "reports"):
        self.excel_file = Path(excel_file)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # Configurar archivos de salida
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.report_file = self.output_dir / f"cisco_audit_{timestamp}.xlsx"
        self.log_file = self.output_dir / f"audit_log_{timestamp}.log"
        
        self.devices = []
        self.results = []
        self.failed_devices = []
        
        self.setup_logging()
        self.ssh_timeout = 30
        self.command_timeout = 10
    
    def setup_logging(self):
        """Configura el sistema de logging detallado"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger('CiscoAudit')
    
    def load_devices(self) -> bool:
        """Carga la lista de dispositivos desde Excel"""
        try:
            self.logger.info(f"Cargando dispositivos desde {self.excel_file}")
            df = pd.read_excel(self.excel_file)
            
            # Validar columnas requeridas
            required_columns = ['IP Address', 'Username', 'Password']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                self.logger.error(f"Columnas faltantes en Excel: {missing_columns}")
                return False
            
            self.devices = df.to_dict('records')
            self.logger.info(f"Cargados {len(self.devices)} dispositivos")
            return True
            
        except Exception as e:
            self.logger.error(f"Error cargando Excel: {str(e)}")
            return False
    
    def connect_to_device(self, device: Dict) -> Optional[paramiko.SSHClient]:
        """Establece conexi√≥n SSH con un dispositivo"""
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        try:
            self.logger.info(f"Conectando a {device['IP Address']}")
            
            ssh.connect(
                hostname=device['IP Address'],
                username=device['Username'],
                password=device['Password'],
                timeout=self.ssh_timeout,
                look_for_keys=False,
                allow_agent=False
            )
            
            return ssh
            
        except socket.timeout:
            self.logger.error(f"Timeout conectando a {device['IP Address']}")
        except paramiko.AuthenticationException:
            self.logger.error(f"Error de autenticaci√≥n en {device['IP Address']}")
        except Exception as e:
            self.logger.error(f"Error conectando a {device['IP Address']}: {str(e)}")
        
        return None
    
    def execute_command(self, ssh: paramiko.SSHClient, command: str) -> Optional[str]:
        """Ejecuta un comando en el dispositivo y retorna el output"""
        try:
            stdin, stdout, stderr = ssh.exec_command(command, timeout=self.command_timeout)
            output = stdout.read().decode('utf-8').strip()
            error = stderr.read().decode('utf-8').strip()
            
            if error:
                self.logger.warning(f"Error en comando '{command}': {error}")
            
            return output
            
        except Exception as e:
            self.logger.error(f"Error ejecutando comando '{command}': {str(e)}")
            return None
    
    def extract_ios_version(self, output: str) -> Dict[str, str]:
        """Extrae informaci√≥n de versi√≥n del output del comando show version"""
        info = {
            'ios_version': 'N/A',
            'device_model': 'N/A',
            'uptime': 'N/A',
            'serial_number': 'N/A'
        }
        
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Extraer versi√≥n IOS
            if 'Cisco IOS Software' in line or 'IOS-XE Software' in line:
                parts = line.split(',')
                if len(parts) > 1:
                    info['ios_version'] = parts[1].strip()
            
            # Extraer modelo
            if 'cisco' in line.lower() and ('router' in line.lower() or 'switch' in line.lower()):
                info['device_model'] = line.strip()
            
            # Extraer uptime
            if 'uptime is' in line.lower():
                info['uptime'] = line.split('uptime is')[1].strip()
            
            # Extraer serial
            if 'Processor board ID' in line:
                info['serial_number'] = line.split('Processor board ID')[1].strip()
        
        return info
    
    def audit_device(self, device: Dict) -> Dict:
        """Audita un dispositivo individual"""
        result = {
            'IP Address': device['IP Address'],
            'Hostname': device.get('Hostname', 'N/A'),
            'Location': device.get('Location', 'N/A'),
            'Status': 'Failed',
            'Error': '',
            'Timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        }
        
        ssh = self.connect_to_device(device)
        if not ssh:
            result['Error'] = 'Conexi√≥n fallida'
            return result
        
        try:
            # Ejecutar comando show version
            output = self.execute_command(ssh, 'show version')
            if output:
                # Extraer informaci√≥n
                ios_info = self.extract_ios_version(output)
                result.update(ios_info)
                result['Status'] = 'Success'
                
                self.logger.info(f"Auditoria exitosa: {device['IP Address']} - {ios_info['ios_version']}")
            else:
                result['Error'] = 'Sin respuesta del comando'
        
        except Exception as e:
            result['Error'] = str(e)
            self.logger.error(f"Error auditando {device['IP Address']}: {str(e)}")
        
        finally:
            ssh.close()
        
        return result
    
    def run_audit(self) -> bool:
        """Ejecuta la auditor√≠a completa"""
        if not self.load_devices():
            return False
        
        self.logger.info("Iniciando auditor√≠a de dispositivos Cisco")
        start_time = datetime.now()
        
        for i, device in enumerate(self.devices, 1):
            self.logger.info(f"Procesando dispositivo {i}/{len(self.devices)}: {device['IP Address']}")
            
            result = self.audit_device(device)
            self.results.append(result)
            
            if result['Status'] == 'Failed':
                self.failed_devices.append(device['IP Address'])
            
            # Peque√±a pausa entre conexiones
            time.sleep(1)
        
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        self.logger.info(f"Auditor√≠a completada en {duration:.2f} segundos")
        self.logger.info(f"Dispositivos exitosos: {len(self.results) - len(self.failed_devices)}")
        self.logger.info(f"Dispositivos fallidos: {len(self.failed_devices)}")
        
        return self.generate_report()
    
    def generate_report(self) -> bool:
        """Genera el reporte Excel con los resultados"""
        try:
            # Crear DataFrame con resultados
            df_results = pd.DataFrame(self.results)
            
            # Crear resumen
            summary_data = {
                'Metric': [
                    'Total Devices',
                    'Successful Audits',
                    'Failed Audits',
                    'Success Rate (%)',
                    'Audit Date'
                ],
                'Value': [
                    len(self.devices),
                    len(self.results) - len(self.failed_devices),
                    len(self.failed_devices),
                    round(((len(self.results) - len(self.failed_devices)) / len(self.devices)) * 100, 2),
                    datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                ]
            }
            df_summary = pd.DataFrame(summary_data)
            
            # Escribir Excel con m√∫ltiples hojas
            with pd.ExcelWriter(self.report_file, engine='openpyxl') as writer:
                df_summary.to_excel(writer, sheet_name='Summary', index=False)
                df_results.to_excel(writer, sheet_name='Detailed Results', index=False)
                
                if self.failed_devices:
                    df_failed = pd.DataFrame({'Failed_IP': self.failed_devices})
                    df_failed.to_excel(writer, sheet_name='Failed Devices', index=False)
            
            self.logger.info(f"Reporte generado: {self.report_file}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error generando reporte: {str(e)}")
            return False

def main():
    """Funci√≥n principal"""
    print("üîß Herramienta de Auditor√≠a Cisco - Hotel de Lujo")
    print("=" * 50)
    
    # Solicitar archivo Excel
    excel_file = input("Ingrese la ruta del archivo Excel con dispositivos: ").strip()
    
    if not Path(excel_file).exists():
        print(f"‚ùå Error: El archivo {excel_file} no existe")
        return
    
    # Crear instancia y ejecutar auditor√≠a
    audit_tool = CiscoAuditTool(excel_file)
    
    print("\nüöÄ Iniciando auditor√≠a...")
    success = audit_tool.run_audit()
    
    if success:
        print(f"\n‚úÖ Auditor√≠a completada exitosamente!")
        print(f"üìä Reporte generado: {audit_tool.report_file}")
        print(f"üìù Log disponible: {audit_tool.log_file}")
    else:
        print("\n‚ùå Error durante la auditor√≠a")

if __name__ == "__main__":
    main()
```

### üìã Plantillas de Prompts para Scripts

#### **Para An√°lisis de Requerimientos**:
```
Analiza este requerimiento de automatizaci√≥n y descomp√≥nlo en:

1. **Inputs necesarios** (archivos, par√°metros, credenciales)
2. **Procesamiento requerido** (conexiones, comandos, l√≥gica)
3. **Outputs esperados** (reportes, logs, alertas)
4. **Manejo de errores** (timeouts, fallos de conexi√≥n, permisos)
5. **Consideraciones de seguridad** (credenciales, logs, acceso)
6. **Usabilidad** (interfaz, mensajes, documentaci√≥n)

Requerimiento: [PEGAR DESCRIPCI√ìN AQU√ç]
```

#### **Para Desarrollo de Scripts**:
```
Genera un script de Python profesional que:

‚úÖ **Funcionalidad**: [descripci√≥n espec√≠fica]
‚úÖ **Inputs**: [archivos/par√°metros de entrada]
‚úÖ **Outputs**: [reportes/archivos de salida]
‚úÖ **Error handling**: Manejo robusto de errores
‚úÖ **Logging**: Sistema de logs detallado
‚úÖ **Documentaci√≥n**: Docstrings y comentarios
‚úÖ **Usabilidad**: Interfaz clara para usuarios no t√©cnicos
‚úÖ **Configurabilidad**: Par√°metros ajustables
‚úÖ **Escalabilidad**: C√≥digo modular y reutilizable

Librer√≠as preferidas: pandas, paramiko, logging, pathlib
Estilo: PEP 8 compliant, type hints, clases cuando apropiado
```

#### **Para Optimizaci√≥n**:
```
Revisa este script y sugiere mejoras en:

1. **Performance**: Optimizaciones de velocidad
2. **Memoria**: Uso eficiente de recursos
3. **Seguridad**: Mejores pr√°cticas de seguridad
4. **Mantenibilidad**: C√≥digo m√°s limpio y modular
5. **Robustez**: Mejor manejo de errores
6. **Usabilidad**: Interfaz m√°s amigable
7. **Testing**: Estrategias de testing

[PEGAR C√ìDIGO AQU√ç]
```

### üéØ Casos de Uso Adicionales

#### **1. Backup Autom√°tico de Configuraciones**
```
Script que:
- Conecte a equipos de red
- Descargue running-config y startup-config
- Los almacene con timestamp
- Compare con versiones anteriores
- Env√≠e alertas por cambios cr√≠ticos
```

#### **2. Monitoreo de Health Status**
```
Script que:
- Verifique CPU, memoria, temperatura
- Valide conectividad de interfaces
- Revise logs de errores recientes
- Genere dashboard de salud general
- Env√≠e alertas proactivas
```

#### **3. Gesti√≥n de VLANs**
```
Script que:
- Audite configuraci√≥n de VLANs
- Verifique consistencia entre switches
- Identifique VLANs hu√©rfanas
- Documente topolog√≠a de red
- Sugiera optimizaciones
```

### üìä Ejercicio Final: Script Personalizado

**Tiempo**: 25 minutos

**Instrucciones**:
1. **Elegir un caso de uso** espec√≠fico para su organizaci√≥n
2. **Definir requerimientos** en lenguaje natural
3. **Usar GitHub Copilot** para generar el script
4. **Iterar y mejorar** basado en feedback del Copilot
5. **Documentar** el script para futura referencia

**Entregables**:
- ‚úÖ Script funcional completo
- ‚úÖ Archivo Excel de ejemplo
- ‚úÖ Documentaci√≥n de uso
- ‚úÖ Plan de implementaci√≥n

### üí° Tips para Maximizar Efectividad

#### **Prompting Efectivo**:
- üéØ **S√© espec√≠fico** sobre el entorno (Cisco, Python, Excel)
- üìù **Incluye contexto** del negocio (hotel, seguridad, auditor√≠a)
- üîÑ **Itera gradualmente** construyendo funcionalidad
- üõ°Ô∏è **Enfatiza robustez** y manejo de errores

#### **Mejores Pr√°cticas**:
- üìö **Modulariza** el c√≥digo desde el inicio
- üîç **Valida inputs** antes del procesamiento
- üì± **Considera m√∫ltiples escenarios** de error
- üé® **Piensa en el usuario final** no t√©cnico

### üèÜ Criterios de √âxito

Al finalizar, cada participante habr√°:

1. **üéØ Transformado requerimientos** naturales en c√≥digo funcional
2. **‚ö° Automatizado tareas** que tomaban horas en minutos
3. **üõ†Ô∏è Creado herramientas** reutilizables para su equipo
4. **üìä Generado reportes** profesionales autom√°ticamente
5. **üîß Aplicado mejores pr√°cticas** de desarrollo y seguridad

**Tiempo total ahorrado por script**: 2-4 horas por ejecuci√≥n
**ROI estimado**: 300-500% en el primer mes